#!/bin/sh
#
# Welcome to GitSync - a commit and push script for easy using git!
# Copyright (C) 2009: Daniel Blaschke and Rene Sedmik
# Copyright (C) 2010: Daniel Blaschke
# Web: http://www.sourceforge.net/projects/gitsync/
#
# This script is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
#
# Last change: 2010-05-19
#
#############################################
# (GLOBAL) OPTIONS:
#############################################
GIT_SERVER="auto"
USE_EDITOR="no"
GIT_DIR=".git"
# change these values to the names of your custom scripts, if
# you have any to be called before and after synchronizing
# with GitSync!
CUSTOM_START_SCRIPT=""
CUSTOM_END_SCRIPT=""
#############################################
# CODE:
#############################################

echo "------------------------------------------------------------"
echo "GitSync 1.2.1 - a GIT update script"
echo "------------------------------------------------------------"

# check for git-installation
GIT_PATH="`which git`"
if [ "$GIT_PATH" = "" ] ; then 
 echo ""
 echo "ERROR: command git not found! Please install the version control system 'git'"
 echo "from www.git-scm.com before using this script!"
 exit 1
fi

#### define functions to be used later in this script:
# function for reading config files
READCFG () {
 if [ "$GS_config" != "" ]; then
    GS_skip="0";
    GS_key="";
    for line in $(cat "$GS_config"); do
     if [ "$GS_key" = "GIT_SERVER" ]; then GIT_SERVER="$line"; fi;
     if [ "$GS_key" = "USE_EDITOR" ]; then USE_EDITOR="$line"; fi;
     if [ "$GS_key" = "GIT_DIR" ]; then GIT_DIR="$line"; fi;
     if [ "$GS_key" = "CUSTOM_START_SCRIPT" ]; then CUSTOM_START_SCRIPT="$line"; fi;
     if [ "$GS_key" = "CUSTOM_END_SCRIPT" ]; then CUSTOM_END_SCRIPT="$line"; fi;
     if [ "$GS_skip" = "0" ]; then
      GS_key=$line;
     else
      GS_skip="0";
     fi;
     if [ "$line" = "#" ]; then GS_skip="1"; fi;
    done
 fi
}

# function for calling git pull/push:
GITP () {
 if git $1; then
  echo "ok."
 else
  echo "ERROR: 'git $1' returned an error."
  exit 2
 fi
}

# function for calling CUSTOM_START/END_SCRIPT:
SCRIPT () {
 if [ "$1" != "" ]; then
  if test -x "./$1"; then
	echo "Calling custom script '$1' ..."
	./$1
	if [ "$1" = "$CUSTOM_START_SCRIPT" ]; then
	 echo "done."
	 echo "---------------------------------------"
	fi
  else
	echo "WARNING: Unable to call your custom script '$1'."
	echo "Make sure it is present and executable!"
  fi
 fi
}

# function for invoking git commit:
GITC () {
 if [ "$GITADDLIST" = "" ]; then
  if [ "$1" = "" ]; then
   git commit -a 
  else
   git commit -a $1 "$2"
  fi
 else
  if [ "$2" = "" ]; then
   git commit
  else
   git commit $1 "$2"
  fi
 fi
}

# function for printing usage information:
USAGE () {
 echo ""
 echo "GitSync-syntax is (where all arguments are optional):"
 echo "gitsync -m 'commit Message' -f 'Files to add' /location/of/repository"
 echo "gitsync -h/--help displays this usage info"
 echo ""
 exit 1
}

####


# parsing command line arguments
GITCOMM=""
GITADDLIST=""
GIT_REP="."

PARSE=""
PARSE_R="0"
PARSE_m="0"
PARSE_f="0"
for i
do
 if [ "$PARSE_R" = "1" ]; then PARSE_R="2"; fi
 if [ "$PARSE_R" = "0" ]; then PARSE_R="1"; fi
 if [ "$PARSE" = "-m" ] && [ "$i" != "-m" ] && [ "$i" != "-f" ] && [ "$PARSE_m" = "0" ]; then 
  GITCOMM=$i
  PARSE_R="0"
  PARSE_m="1"
 fi
 if [ "$PARSE" = "-f" ] && [ "$i" != "-m" ] && [ "$i" != "-f" ] && [ "$PARSE_f" = "0" ]; then 
  GITADDLIST=$i
  PARSE_R="0"
  PARSE_f="1"
 fi
 if [ "$PARSE_R" = "2" ]; then 
  echo "ERROR: invalid command line option '$PARSE $i'."
  USAGE
 fi
 PARSE=$i
done
if [ "$PARSE" != "" ] && [ "$PARSE" != "$GITCOMM" ] && [ "$PARSE" != "$GITADDLIST" ]; then GIT_REP=$PARSE; fi


# if only (or last) argument is -h/--help, print usage and exit
if [ "$GIT_REP" = "-h" ] || [ "$GIT_REP" = "--help" ]; then
 USAGE
fi

# entering the directory of the repository
if cd "$GIT_REP"; then 
 continue
else
 echo ""
 echo "ERROR: folder '$GIT_REP' does not exist. Possibly a mistyped command line argument?"
 USAGE
fi


# searching for custom GitSync-configuration file
GS_config=""
GS_config_all=""
if test -r "$HOME/gitsync.conf"; then GS_config="$HOME/gitsync.conf"; GS_config_all="$GS_config"; fi;
if test -r "$HOME/.gitsync.conf"; then GS_config="$HOME/.gitsync.conf"; GS_config_all="$GS_config"; fi;
READCFG
GS_config=""
if test -r "./gitsync.conf"; then GS_config="./gitsync.conf"; GS_config_all="$GS_config_all $GS_config"; fi;
READCFG
if [ "$GS_config_all" != "" ]; then echo "Config file(s) found: $GS_config_all"; fi;


# check values of variables for validity
if [ "$GIT_SERVER" != "yes" ] && [ "$GIT_SERVER" != "no" ] && [ "$GIT_SERVER" != "auto" ]; then
 echo "ERROR: invalid gitsync-configuration!"
 exit 1
fi

# check if we are in the correct directory
if test -r ./$GIT_DIR/config; then
   dirok=true
else
   echo "ERROR: Please call this script from the base directory of your git-repository!"
   exit 1
fi

# if USE_EDITOR is set to the name of an editor, use it
if [ "$USE_EDITOR" != "yes" ] && [ "$USE_EDITOR" != "no" ]; then
 EDITOR_PATH="`which $USE_EDITOR`"
 if [ "$EDITOR_PATH" = "" ] ; then 
  echo "WARNING: editor '$USE_EDITOR' does not exist, falling back to system default."; 
 else
  export EDITOR=$USE_EDITOR
 fi
 USE_EDITOR="yes"
fi

# if present, calling custom "start" script first
SCRIPT "$CUSTOM_START_SCRIPT"

# if option GIT_SERVER="auto", check file .git/config to decide whether
# GIT_SERVER should be "yes" or "no":
if [ "$GIT_SERVER" = "auto" ]; then
 if [ "$(egrep 'remote' $GIT_DIR/config)" != "" ]; then
	GIT_SERVER="yes"
 else
	GIT_SERVER="no"
 fi
# echo "Checking whether a git-server is configured: $GIT_SERVER"
fi

# check if commit is necessary, else exit after pulling/merging from server
echo "Checking repository status ..."
if [ "$(git status | grep 'nothing to commit')" != "" ]; then
  if [ "$GIT_SERVER" = "yes" ]; then
	echo "Nothing to commit - updating your local repository instead ..."
	GITP pull
	echo "Pushing to the global repository ..."
	GITP push
	# if present, calling custom "end" script before exiting
	SCRIPT "$CUSTOM_END_SCRIPT"
  else
	echo "Nothing to commit (working directory clean)."
  fi
	exit 0
fi
echo "done."
echo "---------------------------------------"

# adding new files to the local repository
echo "Adding new/changed files ..."
if if [ "$GITADDLIST" = "" ]; then
	git add .
   else
#	echo "Only adding: '$GITADDLIST'"
	git add -v $GITADDLIST
   fi; then
  echo "ok."
  echo "---------------------------------------"
else
  echo "ERROR: 'git add' returned an error."
  exit 2
fi

# committing the local changes
echo "Committing all of your changes ..."

if if [ "$GITCOMM" = "" ]; then 
	  if [ "$USE_EDITOR" = "yes" ]; then
		GITC
	  else
		echo "Please type your comment: "
		read gitcomment
		GITC -m "$gitcomment"
	  fi
   else
	  echo "... using your comment: '$GITCOMM'"
	  GITC -m "$GITCOMM"
   fi; then
  echo "ok."
  echo "---------------------------------------"

else
  echo "ERROR: 'git commit' returned an error."
  echo "Undoing 'git add' ..."
  git reset -q
  echo "Aborting due to 'git commit' error."
  exit 2
fi

if [ "$GIT_SERVER" = "yes" ]; then
# initiating a pull to achieve a consistent local repository
 echo "Updating your local repository ..."
 GITP pull
# pushing the changes to the global repo
 echo "Pushing to the global repository ..."
 GITP push
 echo "---------------------------------------"
fi

# if present, calling custom "end" script before exiting
SCRIPT "$CUSTOM_END_SCRIPT"

echo "done."
echo ""

exit 0
# end of script
